import pandas as pd

# Read the files (adjust file names and extensions if needed)
csb = pd.read_excel('csb.xlsx')  # or pd.read_csv('csb.csv')
throughput = pd.read_excel('throughput.xlsx')  # or pd.read_csv('throughput.csv')

# Ensure the column names are stripped of whitespace
csb.columns = csb.columns.str.strip()
throughput.columns = throughput.columns.str.strip()

# Create a mapping from Consumer Reference in throughput to Status
status_map = throughput.set_index('Consumer Reference')['Status'].to_dict()

# Add Mandate Status column to csb by mapping Consumer Reference
csb['Mandate Status'] = csb['Consumer Reference'].map(status_map)

# Save the updated csb to a new file if needed
csb.to_excel('csb_with_mandate_status.xlsx', index=False)



if 'Date' in csb.columns:
    csb['Date'] = pd.to_datetime(csb['Date'], errors='coerce').dt.strftime('%d/%m/2025')


# === Step 6: Create ACH file by removing specific columns ===
columns_to_drop = ['acct', 'user date', 'userdate1']
ach_df = csb.drop(columns=[col for col in columns_to_drop if col in csb.columns])



ach_df = ach_df[ach_df['Mandate Status'].notna()]  # Remove blank/null
ach_df = ach_df[~ach_df['Mandate Status'].str.strip().str.lower().eq('rejected')]




# === Step 9: Update and Write to c.txt ===
with open('c.txt', 'r') as f:
    header_line = f.readline().strip()

# Replace last number in header line with actual row count
parts = header_line.split()
if parts and parts[-1].isdigit():
    parts[-1] = str(len(ach_df)).zfill(2)
header_line_updated = ' '.join(parts)

# Convert ACH data to CSV-style (comma-separated, with header)
ach_csv_text = ach_df.to_csv(index=False)

# Combine header + ach data
final_text = header_line_updated + '\n' + ach_csv_text

# Overwrite c.txt with updated header and data
with open('c.txt', 'w') as f:
    f.write(final_text)







# === Step 9: Read and modify single-line header in c.txt ===
with open('c.txt', 'r') as f:
    header_line = f.readline().rstrip()  # One single line with variable spacing

# Use regex to replace only the last numeric token (trailing row count)
new_count = str(len(ach_df)).zfill(2)
header_line_updated = re.sub(r'(\d+)\s*$', new_count, header_line)

# === Step 10: Convert ACH data to CSV format ===
ach_csv = ach_df.to_csv(index=False)

# === Step 11: Write updated header + CSV data back to c.txt ===
with open('c.txt', 'w') as f:
    f.write(header_line_updated + '\n')
    f.write(ach_csv)




with open('c.txt', 'r') as f:
    lines = f.readlines()

if len(lines) >= 2:
    header_1 = lines[0].rstrip('\n')
    header_2 = lines[1].rstrip('\n')

    # Replace last number in second line with actual row count (preserving spacing)
    new_count = str(len(ach_df)).zfill(2)
    header_2_updated = re.sub(r'(\d+)\s*$', new_count, header_2)

    # Combine updated headers
    updated_txt = header_1 + '\n' + header_2_updated + '\n'

    # Convert ach_df to CSV-style (comma-separated)
    ach_csv = ach_df.to_csv(index=False)

    # Write everything back
    with open('c.txt', 'w') as f:
        f.write(updated_txt)
        f.write(ach_csv)
else:
    print("❌ Error: c.txt must have at least two lines (file header + column header).")














